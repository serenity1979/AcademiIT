
"""
Выведите таблицу размером n×n, заполненную числами от 1 до n 2 по спирали, выходящей из левого верхнего угла и закрученной по часовой стрелке, как показано в примере (здесь n=5):
Sample Input:
5
Sample Output:
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9

"""
n=int(input())
a=[[0 for m in range(n)] for i in range(n)]
i=1
j=int(n/2)
k=int(n/2)
p=int(n/2)
for k in range(1,p+1):
    for j in range(k-1,n-k+1):
        a[k-1][j] = i
        i+=1
    for j in range(k,n-k+1):
        a[j][n-k] = i
        i+=1
    for j in range(n-k-1,k-2,-1):
        a[n-k][j] = i
        i+=1
    for j in range(n-k-1,k-1,-1):
        a[j][k-1] = i
        i+=1
if n%2==1:
    a[p][p]=n*n
for i in range(n):
    for l in range(n):
        print(a[i][l], end=' ')
    print()

'''
варианты решений других:

n = int(input())
# Создаем нулевую квадратную матрицу заданной размерности
a = [[0 for i in range(n)] for j in range(n)]
# Определяем внутренние счетчики для цикла
i = 0 # строки
j = 0 # столбцы
x = 1 # текущее значение для заполнения ячейки
k = 0 # порядковый номер контура
while x <= n*n:
    a[i][j] = x # заполняем ячейку текущим значением
    if i != j: # Только если мы сейчас не на диагонали!
        # Сумма зеркально расположенных элементов одинакова для текущего контура.
        # Она равна нижнему правому значению в контуре, умноженному на 2.
        # Так что на каждом шаге цикла мы заполняем зеркальный элемент матрицы,
        # просто вычитая текущее x из этой суммы ;)
        a[j][i] = (a[k][k] + (n-k*2)*2) * 2 - 4 - x
    if j != n-k-1:
        # если еще не уперлись в правую границу контура, двигаемся вправо
        j += 1      
    elif i != n-k-1:
        # если еще не уперлись в нижнюю границу контура, двигаемся вниз
        i += 1
    elif x != n*n:
        # Если вправо и вниз уже нельзя, значит мы закончили обход текущего контура!
        # Только не забываем проверить, что x не равен n*n, а то будет бо-бо.
        k += 1 # переходим к следующему контуру
        i = j = k # обход следующего контура начнем с координат [k,k]
        x = a[k][k-1] # текущее значение равно наибольшему в старом контуре      
    x += 1 # Ну, и не забываем прибавлять единичку в конце цикла, какое бы условие ни сработало.   
# Выводим на печать
for i in a: print(*i)
 
######or

n = int(input())
x,y,dx,dy, m = 0,0,0,1, [[0]*n for i in range(n)]
for i in range(n*n):
  m[x][y]=str(i+1)
  if x+dx>=n or x+dx<0 or y+dy>=n or y+dy<0 or m[x+dx][y+dy]:
      dx,dy = dy,-dx
  x,y = x+dx, y+dy
print("\n".join([" ".join(i) for i in m]))
'''
